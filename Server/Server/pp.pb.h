// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pp_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pp_2eproto;
class Level;
class LevelDefaultTypeInternal;
extern LevelDefaultTypeInternal _Level_default_instance_;
class Level_MonsterStatus;
class Level_MonsterStatusDefaultTypeInternal;
extern Level_MonsterStatusDefaultTypeInternal _Level_MonsterStatus_default_instance_;
class Levels;
class LevelsDefaultTypeInternal;
extern LevelsDefaultTypeInternal _Levels_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Level* Arena::CreateMaybeMessage<::Level>(Arena*);
template<> ::Level_MonsterStatus* Arena::CreateMaybeMessage<::Level_MonsterStatus>(Arena*);
template<> ::Levels* Arena::CreateMaybeMessage<::Levels>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Level_MissionType : int {
  Level_MissionType_CUTSCENE = 0,
  Level_MissionType_DEFEAT_MONSTER = 1,
  Level_MissionType_DEFEAT_METEOR = 2,
  Level_MissionType_GO_TO_DESTINATION = 3,
  Level_MissionType_TU_SIT = 4,
  Level_MissionType_TU_HEAL = 5,
  Level_MissionType_GET_JEWELS = 6,
  Level_MissionType_DEFEAT_BOSS = 7,
  Level_MissionType_DEFEAT_BOSS2 = 8,
  Level_MissionType_GO_CENTER = 9,
  Level_MissionType_ESCAPE_BLACK_HOLE = 10,
  Level_MissionType_KILL_GOD = 11,
  Level_MissionType_KILL_GOD2 = 12,
  Level_MissionType_CS_ENDING = 13,
  Level_MissionType_CS_BAD_ENDING = 14,
  Level_MissionType_Level_MissionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Level_MissionType_Level_MissionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Level_MissionType_IsValid(int value);
constexpr Level_MissionType Level_MissionType_MissionType_MIN = Level_MissionType_CUTSCENE;
constexpr Level_MissionType Level_MissionType_MissionType_MAX = Level_MissionType_CS_BAD_ENDING;
constexpr int Level_MissionType_MissionType_ARRAYSIZE = Level_MissionType_MissionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Level_MissionType_descriptor();
template<typename T>
inline const std::string& Level_MissionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Level_MissionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Level_MissionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Level_MissionType_descriptor(), enum_t_value);
}
inline bool Level_MissionType_Parse(
    const std::string& name, Level_MissionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Level_MissionType>(
    Level_MissionType_descriptor(), name, value);
}
// ===================================================================

class Level_MonsterStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Level.MonsterStatus) */ {
 public:
  Level_MonsterStatus();
  virtual ~Level_MonsterStatus();

  Level_MonsterStatus(const Level_MonsterStatus& from);
  Level_MonsterStatus(Level_MonsterStatus&& from) noexcept
    : Level_MonsterStatus() {
    *this = ::std::move(from);
  }

  inline Level_MonsterStatus& operator=(const Level_MonsterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Level_MonsterStatus& operator=(Level_MonsterStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Level_MonsterStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Level_MonsterStatus* internal_default_instance() {
    return reinterpret_cast<const Level_MonsterStatus*>(
               &_Level_MonsterStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Level_MonsterStatus& a, Level_MonsterStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(Level_MonsterStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Level_MonsterStatus* New() const final {
    return CreateMaybeMessage<Level_MonsterStatus>(nullptr);
  }

  Level_MonsterStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Level_MonsterStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Level_MonsterStatus& from);
  void MergeFrom(const Level_MonsterStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Level_MonsterStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Level.MonsterStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pp_2eproto);
    return ::descriptor_table_pp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMAXHPFieldNumber = 1,
    kATKFieldNumber = 2,
  };
  // int32 MAX_HP = 1;
  void clear_max_hp();
  ::PROTOBUF_NAMESPACE_ID::int32 max_hp() const;
  void set_max_hp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_hp() const;
  void _internal_set_max_hp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ATK = 2;
  void clear_atk();
  ::PROTOBUF_NAMESPACE_ID::int32 atk() const;
  void set_atk(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_atk() const;
  void _internal_set_atk(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Level.MonsterStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_hp_;
  ::PROTOBUF_NAMESPACE_ID::int32 atk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pp_2eproto;
};
// -------------------------------------------------------------------

class Level :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Level) */ {
 public:
  Level();
  virtual ~Level();

  Level(const Level& from);
  Level(Level&& from) noexcept
    : Level() {
    *this = ::std::move(from);
  }

  inline Level& operator=(const Level& from) {
    CopyFrom(from);
    return *this;
  }
  inline Level& operator=(Level&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Level& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Level* internal_default_instance() {
    return reinterpret_cast<const Level*>(
               &_Level_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Level& a, Level& b) {
    a.Swap(&b);
  }
  inline void Swap(Level* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Level* New() const final {
    return CreateMaybeMessage<Level>(nullptr);
  }

  Level* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Level>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Level& from);
  void MergeFrom(const Level& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Level* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Level";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pp_2eproto);
    return ::descriptor_table_pp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Level_MonsterStatus MonsterStatus;

  typedef Level_MissionType MissionType;
  static constexpr MissionType CUTSCENE =
    Level_MissionType_CUTSCENE;
  static constexpr MissionType DEFEAT_MONSTER =
    Level_MissionType_DEFEAT_MONSTER;
  static constexpr MissionType DEFEAT_METEOR =
    Level_MissionType_DEFEAT_METEOR;
  static constexpr MissionType GO_TO_DESTINATION =
    Level_MissionType_GO_TO_DESTINATION;
  static constexpr MissionType TU_SIT =
    Level_MissionType_TU_SIT;
  static constexpr MissionType TU_HEAL =
    Level_MissionType_TU_HEAL;
  static constexpr MissionType GET_JEWELS =
    Level_MissionType_GET_JEWELS;
  static constexpr MissionType DEFEAT_BOSS =
    Level_MissionType_DEFEAT_BOSS;
  static constexpr MissionType DEFEAT_BOSS2 =
    Level_MissionType_DEFEAT_BOSS2;
  static constexpr MissionType GO_CENTER =
    Level_MissionType_GO_CENTER;
  static constexpr MissionType ESCAPE_BLACK_HOLE =
    Level_MissionType_ESCAPE_BLACK_HOLE;
  static constexpr MissionType KILL_GOD =
    Level_MissionType_KILL_GOD;
  static constexpr MissionType KILL_GOD2 =
    Level_MissionType_KILL_GOD2;
  static constexpr MissionType CS_ENDING =
    Level_MissionType_CS_ENDING;
  static constexpr MissionType CS_BAD_ENDING =
    Level_MissionType_CS_BAD_ENDING;
  static inline bool MissionType_IsValid(int value) {
    return Level_MissionType_IsValid(value);
  }
  static constexpr MissionType MissionType_MIN =
    Level_MissionType_MissionType_MIN;
  static constexpr MissionType MissionType_MAX =
    Level_MissionType_MissionType_MAX;
  static constexpr int MissionType_ARRAYSIZE =
    Level_MissionType_MissionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MissionType_descriptor() {
    return Level_MissionType_descriptor();
  }
  template<typename T>
  static inline const std::string& MissionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MissionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MissionType_Name.");
    return Level_MissionType_Name(enum_t_value);
  }
  static inline bool MissionType_Parse(const std::string& name,
      MissionType* value) {
    return Level_MissionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlasmaCannonFieldNumber = 3,
    kMissileFieldNumber = 4,
    kLaserFieldNumber = 5,
    kCurMissionFieldNumber = 1,
    kNextMissionFieldNumber = 2,
    kMaxMonsterNumFieldNumber = 6,
    kSpawnMonsterNumFieldNumber = 7,
    kRequirementFieldNumber = 8,
    kRestartMissionFieldNumber = 9,
    kRestartPositionXFieldNumber = 10,
    kRestartPositionYFieldNumber = 11,
    kRestartPositionZFieldNumber = 12,
    kKillMonsterNumFieldNumber = 13,
    kDestinationXFieldNumber = 14,
    kDestinationYFieldNumber = 15,
    kDestinationZFieldNumber = 16,
    kDistFieldNumber = 17,
  };
  // .Level.MonsterStatus PlasmaCannon = 3;
  bool has_plasmacannon() const;
  private:
  bool _internal_has_plasmacannon() const;
  public:
  void clear_plasmacannon();
  const ::Level_MonsterStatus& plasmacannon() const;
  ::Level_MonsterStatus* release_plasmacannon();
  ::Level_MonsterStatus* mutable_plasmacannon();
  void set_allocated_plasmacannon(::Level_MonsterStatus* plasmacannon);
  private:
  const ::Level_MonsterStatus& _internal_plasmacannon() const;
  ::Level_MonsterStatus* _internal_mutable_plasmacannon();
  public:

  // .Level.MonsterStatus Missile = 4;
  bool has_missile() const;
  private:
  bool _internal_has_missile() const;
  public:
  void clear_missile();
  const ::Level_MonsterStatus& missile() const;
  ::Level_MonsterStatus* release_missile();
  ::Level_MonsterStatus* mutable_missile();
  void set_allocated_missile(::Level_MonsterStatus* missile);
  private:
  const ::Level_MonsterStatus& _internal_missile() const;
  ::Level_MonsterStatus* _internal_mutable_missile();
  public:

  // .Level.MonsterStatus Laser = 5;
  bool has_laser() const;
  private:
  bool _internal_has_laser() const;
  public:
  void clear_laser();
  const ::Level_MonsterStatus& laser() const;
  ::Level_MonsterStatus* release_laser();
  ::Level_MonsterStatus* mutable_laser();
  void set_allocated_laser(::Level_MonsterStatus* laser);
  private:
  const ::Level_MonsterStatus& _internal_laser() const;
  ::Level_MonsterStatus* _internal_mutable_laser();
  public:

  // int32 CurMission = 1;
  void clear_curmission();
  ::PROTOBUF_NAMESPACE_ID::int32 curmission() const;
  void set_curmission(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curmission() const;
  void _internal_set_curmission(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 NextMission = 2;
  void clear_nextmission();
  ::PROTOBUF_NAMESPACE_ID::int32 nextmission() const;
  void set_nextmission(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nextmission() const;
  void _internal_set_nextmission(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 MaxMonsterNum = 6;
  void clear_maxmonsternum();
  ::PROTOBUF_NAMESPACE_ID::int32 maxmonsternum() const;
  void set_maxmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxmonsternum() const;
  void _internal_set_maxmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 SpawnMonsterNum = 7;
  void clear_spawnmonsternum();
  ::PROTOBUF_NAMESPACE_ID::int32 spawnmonsternum() const;
  void set_spawnmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_spawnmonsternum() const;
  void _internal_set_spawnmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .Level.MissionType Requirement = 8;
  void clear_requirement();
  ::Level_MissionType requirement() const;
  void set_requirement(::Level_MissionType value);
  private:
  ::Level_MissionType _internal_requirement() const;
  void _internal_set_requirement(::Level_MissionType value);
  public:

  // int32 RestartMission = 9;
  void clear_restartmission();
  ::PROTOBUF_NAMESPACE_ID::int32 restartmission() const;
  void set_restartmission(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_restartmission() const;
  void _internal_set_restartmission(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float RestartPosition_x = 10;
  void clear_restartposition_x();
  float restartposition_x() const;
  void set_restartposition_x(float value);
  private:
  float _internal_restartposition_x() const;
  void _internal_set_restartposition_x(float value);
  public:

  // float RestartPosition_y = 11;
  void clear_restartposition_y();
  float restartposition_y() const;
  void set_restartposition_y(float value);
  private:
  float _internal_restartposition_y() const;
  void _internal_set_restartposition_y(float value);
  public:

  // float RestartPosition_z = 12;
  void clear_restartposition_z();
  float restartposition_z() const;
  void set_restartposition_z(float value);
  private:
  float _internal_restartposition_z() const;
  void _internal_set_restartposition_z(float value);
  public:

  // int32 KillMonsterNum = 13;
  void clear_killmonsternum();
  ::PROTOBUF_NAMESPACE_ID::int32 killmonsternum() const;
  void set_killmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_killmonsternum() const;
  void _internal_set_killmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float Destination_x = 14;
  void clear_destination_x();
  float destination_x() const;
  void set_destination_x(float value);
  private:
  float _internal_destination_x() const;
  void _internal_set_destination_x(float value);
  public:

  // float Destination_y = 15;
  void clear_destination_y();
  float destination_y() const;
  void set_destination_y(float value);
  private:
  float _internal_destination_y() const;
  void _internal_set_destination_y(float value);
  public:

  // float Destination_z = 16;
  void clear_destination_z();
  float destination_z() const;
  void set_destination_z(float value);
  private:
  float _internal_destination_z() const;
  void _internal_set_destination_z(float value);
  public:

  // float Dist = 17;
  void clear_dist();
  float dist() const;
  void set_dist(float value);
  private:
  float _internal_dist() const;
  void _internal_set_dist(float value);
  public:

  // @@protoc_insertion_point(class_scope:Level)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Level_MonsterStatus* plasmacannon_;
  ::Level_MonsterStatus* missile_;
  ::Level_MonsterStatus* laser_;
  ::PROTOBUF_NAMESPACE_ID::int32 curmission_;
  ::PROTOBUF_NAMESPACE_ID::int32 nextmission_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxmonsternum_;
  ::PROTOBUF_NAMESPACE_ID::int32 spawnmonsternum_;
  int requirement_;
  ::PROTOBUF_NAMESPACE_ID::int32 restartmission_;
  float restartposition_x_;
  float restartposition_y_;
  float restartposition_z_;
  ::PROTOBUF_NAMESPACE_ID::int32 killmonsternum_;
  float destination_x_;
  float destination_y_;
  float destination_z_;
  float dist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pp_2eproto;
};
// -------------------------------------------------------------------

class Levels :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Levels) */ {
 public:
  Levels();
  virtual ~Levels();

  Levels(const Levels& from);
  Levels(Levels&& from) noexcept
    : Levels() {
    *this = ::std::move(from);
  }

  inline Levels& operator=(const Levels& from) {
    CopyFrom(from);
    return *this;
  }
  inline Levels& operator=(Levels&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Levels& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Levels* internal_default_instance() {
    return reinterpret_cast<const Levels*>(
               &_Levels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Levels& a, Levels& b) {
    a.Swap(&b);
  }
  inline void Swap(Levels* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Levels* New() const final {
    return CreateMaybeMessage<Levels>(nullptr);
  }

  Levels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Levels>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Levels& from);
  void MergeFrom(const Levels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Levels* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Levels";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pp_2eproto);
    return ::descriptor_table_pp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // repeated .Level level = 1;
  int level_size() const;
  private:
  int _internal_level_size() const;
  public:
  void clear_level();
  ::Level* mutable_level(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Level >*
      mutable_level();
  private:
  const ::Level& _internal_level(int index) const;
  ::Level* _internal_add_level();
  public:
  const ::Level& level(int index) const;
  ::Level* add_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Level >&
      level() const;

  // @@protoc_insertion_point(class_scope:Levels)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Level > level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Level_MonsterStatus

// int32 MAX_HP = 1;
inline void Level_MonsterStatus::clear_max_hp() {
  max_hp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level_MonsterStatus::_internal_max_hp() const {
  return max_hp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level_MonsterStatus::max_hp() const {
  // @@protoc_insertion_point(field_get:Level.MonsterStatus.MAX_HP)
  return _internal_max_hp();
}
inline void Level_MonsterStatus::_internal_set_max_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_hp_ = value;
}
inline void Level_MonsterStatus::set_max_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_hp(value);
  // @@protoc_insertion_point(field_set:Level.MonsterStatus.MAX_HP)
}

// int32 ATK = 2;
inline void Level_MonsterStatus::clear_atk() {
  atk_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level_MonsterStatus::_internal_atk() const {
  return atk_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level_MonsterStatus::atk() const {
  // @@protoc_insertion_point(field_get:Level.MonsterStatus.ATK)
  return _internal_atk();
}
inline void Level_MonsterStatus::_internal_set_atk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  atk_ = value;
}
inline void Level_MonsterStatus::set_atk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_atk(value);
  // @@protoc_insertion_point(field_set:Level.MonsterStatus.ATK)
}

// -------------------------------------------------------------------

// Level

// int32 CurMission = 1;
inline void Level::clear_curmission() {
  curmission_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::_internal_curmission() const {
  return curmission_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::curmission() const {
  // @@protoc_insertion_point(field_get:Level.CurMission)
  return _internal_curmission();
}
inline void Level::_internal_set_curmission(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curmission_ = value;
}
inline void Level::set_curmission(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curmission(value);
  // @@protoc_insertion_point(field_set:Level.CurMission)
}

// int32 NextMission = 2;
inline void Level::clear_nextmission() {
  nextmission_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::_internal_nextmission() const {
  return nextmission_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::nextmission() const {
  // @@protoc_insertion_point(field_get:Level.NextMission)
  return _internal_nextmission();
}
inline void Level::_internal_set_nextmission(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nextmission_ = value;
}
inline void Level::set_nextmission(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nextmission(value);
  // @@protoc_insertion_point(field_set:Level.NextMission)
}

// .Level.MonsterStatus PlasmaCannon = 3;
inline bool Level::_internal_has_plasmacannon() const {
  return this != internal_default_instance() && plasmacannon_ != nullptr;
}
inline bool Level::has_plasmacannon() const {
  return _internal_has_plasmacannon();
}
inline void Level::clear_plasmacannon() {
  if (GetArenaNoVirtual() == nullptr && plasmacannon_ != nullptr) {
    delete plasmacannon_;
  }
  plasmacannon_ = nullptr;
}
inline const ::Level_MonsterStatus& Level::_internal_plasmacannon() const {
  const ::Level_MonsterStatus* p = plasmacannon_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Level_MonsterStatus*>(
      &::_Level_MonsterStatus_default_instance_);
}
inline const ::Level_MonsterStatus& Level::plasmacannon() const {
  // @@protoc_insertion_point(field_get:Level.PlasmaCannon)
  return _internal_plasmacannon();
}
inline ::Level_MonsterStatus* Level::release_plasmacannon() {
  // @@protoc_insertion_point(field_release:Level.PlasmaCannon)
  
  ::Level_MonsterStatus* temp = plasmacannon_;
  plasmacannon_ = nullptr;
  return temp;
}
inline ::Level_MonsterStatus* Level::_internal_mutable_plasmacannon() {
  
  if (plasmacannon_ == nullptr) {
    auto* p = CreateMaybeMessage<::Level_MonsterStatus>(GetArenaNoVirtual());
    plasmacannon_ = p;
  }
  return plasmacannon_;
}
inline ::Level_MonsterStatus* Level::mutable_plasmacannon() {
  // @@protoc_insertion_point(field_mutable:Level.PlasmaCannon)
  return _internal_mutable_plasmacannon();
}
inline void Level::set_allocated_plasmacannon(::Level_MonsterStatus* plasmacannon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete plasmacannon_;
  }
  if (plasmacannon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      plasmacannon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plasmacannon, submessage_arena);
    }
    
  } else {
    
  }
  plasmacannon_ = plasmacannon;
  // @@protoc_insertion_point(field_set_allocated:Level.PlasmaCannon)
}

// .Level.MonsterStatus Missile = 4;
inline bool Level::_internal_has_missile() const {
  return this != internal_default_instance() && missile_ != nullptr;
}
inline bool Level::has_missile() const {
  return _internal_has_missile();
}
inline void Level::clear_missile() {
  if (GetArenaNoVirtual() == nullptr && missile_ != nullptr) {
    delete missile_;
  }
  missile_ = nullptr;
}
inline const ::Level_MonsterStatus& Level::_internal_missile() const {
  const ::Level_MonsterStatus* p = missile_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Level_MonsterStatus*>(
      &::_Level_MonsterStatus_default_instance_);
}
inline const ::Level_MonsterStatus& Level::missile() const {
  // @@protoc_insertion_point(field_get:Level.Missile)
  return _internal_missile();
}
inline ::Level_MonsterStatus* Level::release_missile() {
  // @@protoc_insertion_point(field_release:Level.Missile)
  
  ::Level_MonsterStatus* temp = missile_;
  missile_ = nullptr;
  return temp;
}
inline ::Level_MonsterStatus* Level::_internal_mutable_missile() {
  
  if (missile_ == nullptr) {
    auto* p = CreateMaybeMessage<::Level_MonsterStatus>(GetArenaNoVirtual());
    missile_ = p;
  }
  return missile_;
}
inline ::Level_MonsterStatus* Level::mutable_missile() {
  // @@protoc_insertion_point(field_mutable:Level.Missile)
  return _internal_mutable_missile();
}
inline void Level::set_allocated_missile(::Level_MonsterStatus* missile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete missile_;
  }
  if (missile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      missile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, missile, submessage_arena);
    }
    
  } else {
    
  }
  missile_ = missile;
  // @@protoc_insertion_point(field_set_allocated:Level.Missile)
}

// .Level.MonsterStatus Laser = 5;
inline bool Level::_internal_has_laser() const {
  return this != internal_default_instance() && laser_ != nullptr;
}
inline bool Level::has_laser() const {
  return _internal_has_laser();
}
inline void Level::clear_laser() {
  if (GetArenaNoVirtual() == nullptr && laser_ != nullptr) {
    delete laser_;
  }
  laser_ = nullptr;
}
inline const ::Level_MonsterStatus& Level::_internal_laser() const {
  const ::Level_MonsterStatus* p = laser_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Level_MonsterStatus*>(
      &::_Level_MonsterStatus_default_instance_);
}
inline const ::Level_MonsterStatus& Level::laser() const {
  // @@protoc_insertion_point(field_get:Level.Laser)
  return _internal_laser();
}
inline ::Level_MonsterStatus* Level::release_laser() {
  // @@protoc_insertion_point(field_release:Level.Laser)
  
  ::Level_MonsterStatus* temp = laser_;
  laser_ = nullptr;
  return temp;
}
inline ::Level_MonsterStatus* Level::_internal_mutable_laser() {
  
  if (laser_ == nullptr) {
    auto* p = CreateMaybeMessage<::Level_MonsterStatus>(GetArenaNoVirtual());
    laser_ = p;
  }
  return laser_;
}
inline ::Level_MonsterStatus* Level::mutable_laser() {
  // @@protoc_insertion_point(field_mutable:Level.Laser)
  return _internal_mutable_laser();
}
inline void Level::set_allocated_laser(::Level_MonsterStatus* laser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete laser_;
  }
  if (laser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      laser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laser, submessage_arena);
    }
    
  } else {
    
  }
  laser_ = laser;
  // @@protoc_insertion_point(field_set_allocated:Level.Laser)
}

// int32 MaxMonsterNum = 6;
inline void Level::clear_maxmonsternum() {
  maxmonsternum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::_internal_maxmonsternum() const {
  return maxmonsternum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::maxmonsternum() const {
  // @@protoc_insertion_point(field_get:Level.MaxMonsterNum)
  return _internal_maxmonsternum();
}
inline void Level::_internal_set_maxmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxmonsternum_ = value;
}
inline void Level::set_maxmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxmonsternum(value);
  // @@protoc_insertion_point(field_set:Level.MaxMonsterNum)
}

// int32 SpawnMonsterNum = 7;
inline void Level::clear_spawnmonsternum() {
  spawnmonsternum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::_internal_spawnmonsternum() const {
  return spawnmonsternum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::spawnmonsternum() const {
  // @@protoc_insertion_point(field_get:Level.SpawnMonsterNum)
  return _internal_spawnmonsternum();
}
inline void Level::_internal_set_spawnmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  spawnmonsternum_ = value;
}
inline void Level::set_spawnmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_spawnmonsternum(value);
  // @@protoc_insertion_point(field_set:Level.SpawnMonsterNum)
}

// .Level.MissionType Requirement = 8;
inline void Level::clear_requirement() {
  requirement_ = 0;
}
inline ::Level_MissionType Level::_internal_requirement() const {
  return static_cast< ::Level_MissionType >(requirement_);
}
inline ::Level_MissionType Level::requirement() const {
  // @@protoc_insertion_point(field_get:Level.Requirement)
  return _internal_requirement();
}
inline void Level::_internal_set_requirement(::Level_MissionType value) {
  
  requirement_ = value;
}
inline void Level::set_requirement(::Level_MissionType value) {
  _internal_set_requirement(value);
  // @@protoc_insertion_point(field_set:Level.Requirement)
}

// int32 RestartMission = 9;
inline void Level::clear_restartmission() {
  restartmission_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::_internal_restartmission() const {
  return restartmission_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::restartmission() const {
  // @@protoc_insertion_point(field_get:Level.RestartMission)
  return _internal_restartmission();
}
inline void Level::_internal_set_restartmission(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  restartmission_ = value;
}
inline void Level::set_restartmission(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_restartmission(value);
  // @@protoc_insertion_point(field_set:Level.RestartMission)
}

// float RestartPosition_x = 10;
inline void Level::clear_restartposition_x() {
  restartposition_x_ = 0;
}
inline float Level::_internal_restartposition_x() const {
  return restartposition_x_;
}
inline float Level::restartposition_x() const {
  // @@protoc_insertion_point(field_get:Level.RestartPosition_x)
  return _internal_restartposition_x();
}
inline void Level::_internal_set_restartposition_x(float value) {
  
  restartposition_x_ = value;
}
inline void Level::set_restartposition_x(float value) {
  _internal_set_restartposition_x(value);
  // @@protoc_insertion_point(field_set:Level.RestartPosition_x)
}

// float RestartPosition_y = 11;
inline void Level::clear_restartposition_y() {
  restartposition_y_ = 0;
}
inline float Level::_internal_restartposition_y() const {
  return restartposition_y_;
}
inline float Level::restartposition_y() const {
  // @@protoc_insertion_point(field_get:Level.RestartPosition_y)
  return _internal_restartposition_y();
}
inline void Level::_internal_set_restartposition_y(float value) {
  
  restartposition_y_ = value;
}
inline void Level::set_restartposition_y(float value) {
  _internal_set_restartposition_y(value);
  // @@protoc_insertion_point(field_set:Level.RestartPosition_y)
}

// float RestartPosition_z = 12;
inline void Level::clear_restartposition_z() {
  restartposition_z_ = 0;
}
inline float Level::_internal_restartposition_z() const {
  return restartposition_z_;
}
inline float Level::restartposition_z() const {
  // @@protoc_insertion_point(field_get:Level.RestartPosition_z)
  return _internal_restartposition_z();
}
inline void Level::_internal_set_restartposition_z(float value) {
  
  restartposition_z_ = value;
}
inline void Level::set_restartposition_z(float value) {
  _internal_set_restartposition_z(value);
  // @@protoc_insertion_point(field_set:Level.RestartPosition_z)
}

// int32 KillMonsterNum = 13;
inline void Level::clear_killmonsternum() {
  killmonsternum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::_internal_killmonsternum() const {
  return killmonsternum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Level::killmonsternum() const {
  // @@protoc_insertion_point(field_get:Level.KillMonsterNum)
  return _internal_killmonsternum();
}
inline void Level::_internal_set_killmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  killmonsternum_ = value;
}
inline void Level::set_killmonsternum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_killmonsternum(value);
  // @@protoc_insertion_point(field_set:Level.KillMonsterNum)
}

// float Destination_x = 14;
inline void Level::clear_destination_x() {
  destination_x_ = 0;
}
inline float Level::_internal_destination_x() const {
  return destination_x_;
}
inline float Level::destination_x() const {
  // @@protoc_insertion_point(field_get:Level.Destination_x)
  return _internal_destination_x();
}
inline void Level::_internal_set_destination_x(float value) {
  
  destination_x_ = value;
}
inline void Level::set_destination_x(float value) {
  _internal_set_destination_x(value);
  // @@protoc_insertion_point(field_set:Level.Destination_x)
}

// float Destination_y = 15;
inline void Level::clear_destination_y() {
  destination_y_ = 0;
}
inline float Level::_internal_destination_y() const {
  return destination_y_;
}
inline float Level::destination_y() const {
  // @@protoc_insertion_point(field_get:Level.Destination_y)
  return _internal_destination_y();
}
inline void Level::_internal_set_destination_y(float value) {
  
  destination_y_ = value;
}
inline void Level::set_destination_y(float value) {
  _internal_set_destination_y(value);
  // @@protoc_insertion_point(field_set:Level.Destination_y)
}

// float Destination_z = 16;
inline void Level::clear_destination_z() {
  destination_z_ = 0;
}
inline float Level::_internal_destination_z() const {
  return destination_z_;
}
inline float Level::destination_z() const {
  // @@protoc_insertion_point(field_get:Level.Destination_z)
  return _internal_destination_z();
}
inline void Level::_internal_set_destination_z(float value) {
  
  destination_z_ = value;
}
inline void Level::set_destination_z(float value) {
  _internal_set_destination_z(value);
  // @@protoc_insertion_point(field_set:Level.Destination_z)
}

// float Dist = 17;
inline void Level::clear_dist() {
  dist_ = 0;
}
inline float Level::_internal_dist() const {
  return dist_;
}
inline float Level::dist() const {
  // @@protoc_insertion_point(field_get:Level.Dist)
  return _internal_dist();
}
inline void Level::_internal_set_dist(float value) {
  
  dist_ = value;
}
inline void Level::set_dist(float value) {
  _internal_set_dist(value);
  // @@protoc_insertion_point(field_set:Level.Dist)
}

// -------------------------------------------------------------------

// Levels

// repeated .Level level = 1;
inline int Levels::_internal_level_size() const {
  return level_.size();
}
inline int Levels::level_size() const {
  return _internal_level_size();
}
inline void Levels::clear_level() {
  level_.Clear();
}
inline ::Level* Levels::mutable_level(int index) {
  // @@protoc_insertion_point(field_mutable:Levels.level)
  return level_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Level >*
Levels::mutable_level() {
  // @@protoc_insertion_point(field_mutable_list:Levels.level)
  return &level_;
}
inline const ::Level& Levels::_internal_level(int index) const {
  return level_.Get(index);
}
inline const ::Level& Levels::level(int index) const {
  // @@protoc_insertion_point(field_get:Levels.level)
  return _internal_level(index);
}
inline ::Level* Levels::_internal_add_level() {
  return level_.Add();
}
inline ::Level* Levels::add_level() {
  // @@protoc_insertion_point(field_add:Levels.level)
  return _internal_add_level();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Level >&
Levels::level() const {
  // @@protoc_insertion_point(field_list:Levels.level)
  return level_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Level_MissionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Level_MissionType>() {
  return ::Level_MissionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pp_2eproto
